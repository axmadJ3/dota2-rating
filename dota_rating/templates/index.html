{% load static %}

<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Game Turbo Rating</title>
  <link rel="stylesheet" href="{% static 'style.css' %}"/>
</head>

<body>
  <div id="notification" style="display: none;"></div>
  <input type="hidden" id="csrf-token" value="{{ csrf_token }}">
  <header>
    <div class="header-left">
      <h1>Turbo Rating</h1>
    </div>
    <div class="header-right">
      {% if request.user.is_authenticated %}
        <button id="refresh-rating">Refresh rating</button>
        <a href="{% url "auth:logout" %}">
          <button id="signout-steam">Sign Out</button>
        </a>
      {% else %}
        <a href="{% url "social:begin" "steam" %}">
          <button id="auth-steam">Auth via Steam</button>
        </a>
      {% endif %}
      <div class="user-info">
        {% if request.user.is_authenticated %}
          <span id="user-nickname">{{ request.user.personaname }}</span> |
          <span id="user-rating">{{ user_total_rating }}</span>
        {% else %}
          <span id="user-nickname">Guest</span> |
          <span id="user-rating">1</span>
        {% endif %}
      </div>
    </div>
  </header>

  <nav>
    <button class="active" data-tab="rating">Table Rating</button>
    {% if request.user.is_authenticated %}
      <button data-tab="stats">Your Stat</button>
    {% endif %}
  </nav>

  <!-- Table Rating Tab -->
  <div class="tab-content" id="rating-tab">
    <table>
      <thead>
        <tr>
          <th>Position</th>
          <th>Nickname</th>
          <th>Rating</th>
        </tr>
      </thead>
      <tbody id="leaderboard-body">
        <!-- динамически загружается -->
      </tbody>
    </table>
  </div>

  <div id="user-position-row" class="more-row" style="display: none;"></div>

  <!-- Your Stat Tab -->
  {% if request.user.is_authenticated %}
    <div class="tab-content" id="stats-tab" style="display:none;">
      <table id="stats-table">
        <thead>
          <tr>
            <th>Time</th>
            <th>Duration</th>
            <th>Hero</th>
            <th>Result</th>
            <th>K</th>
            <th>D</th>
            <th>A</th>
            <th>Rating</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <div id="loading" class="more-row">Загрузка...</div>
    </div>
  {% else %}
    <div class="tab-content" style="text-align: center;">
      <h2 style="margin-top: 40px;">Авторизуйтесь через Steam, чтобы посмотреть свою статистику</h2>
      <a href="{% url "social:begin" "steam" %}">
        <button id="auth-steam" style="margin-top: 20px;">Auth via Steam</button>
      </a>
    </div>
  {% endif %}

<script>
  const tabs = document.querySelectorAll('nav button');
  const ratingTab = document.getElementById('rating-tab');
  const statsTab = document.getElementById('stats-tab');
  const refreshBtn = document.getElementById('refresh-rating');
  const leaderboardBody = document.getElementById('leaderboard-body');
  const statsBody = document.querySelector('#stats-table tbody');
  const loadingIndicator = document.getElementById('loading');
  const userRatingSpan = document.getElementById('user-rating');

  let offset = 0;
  let limit = 20;
  let loading = false;

  {% if request.user.is_authenticated %}
  const CURRENT_USER_STEAM_ID = "{{ request.user.steamid }}";
  {% endif %}

  function showNotification(message, duration = 3000) {
    const notification = document.getElementById('notification');
    notification.textContent = message;
    notification.style.display = 'block';
    notification.style.opacity = '1';
    setTimeout(() => {
      notification.style.opacity = '0';
      setTimeout(() => {
        notification.style.display = 'none';
      }, 300);
    }, duration);
  }

  tabs.forEach(btn => {
    btn.addEventListener('click', () => {
      tabs.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      ratingTab.style.display = btn.dataset.tab === 'rating' ? 'block' : 'none';
      if (statsTab) statsTab.style.display = btn.dataset.tab === 'stats' ? 'block' : 'none';
      if (btn.dataset.tab === 'stats' && statsBody && statsBody.childElementCount === 0) {
        loadStats();
      }
    });
  });

  function formatDuration(seconds) {
    const min = Math.floor(seconds / 60);
    const sec = seconds % 60;
    return `${min}:${sec.toString().padStart(2, '0')}`;
  }

  async function loadStats() {
    if (loading) return;
    loading = true;
    loadingIndicator.style.display = 'block';
    try {
      const resp = await fetch(`/api/user/stats?steam_id=${CURRENT_USER_STEAM_ID}&offset=${offset}&limit=${limit}`);
      const games = await resp.json();
      games.forEach(game => {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${new Date(game.time).toLocaleString()}</td>
          <td>${formatDuration(game.duration)}</td>
          <td>${game.hero}</td>
          <td>${game.result}</td>
          <td>${game.kills}</td>
          <td>${game.deaths}</td>
          <td>${game.assists}</td>
          <td>${game.rating}</td>
        `;
        statsBody.appendChild(row);
      });
      offset += games.length;
      if (games.length < limit) {
        loadingIndicator.textContent = 'Больше нет игр';
        statsTab.removeEventListener('scroll', handleScroll);
      }
    } catch (e) {
      console.error('Ошибка загрузки матчей', e);
    } finally {
      loading = false;
      loadingIndicator.style.display = 'none';
    }
  }

  function handleScroll() {
    const { scrollTop, scrollHeight, clientHeight } = statsTab;
    if (scrollTop + clientHeight >= scrollHeight - 50) {
      loadStats();
    }
  }

  if (statsTab) {
    statsTab.addEventListener('scroll', handleScroll);
  }

  if (refreshBtn) {
    refreshBtn.addEventListener('click', async () => {
      offset = 0;
      statsBody.innerHTML = '';
      statsTab.addEventListener('scroll', handleScroll);
      loadingIndicator.textContent = 'Загрузка...';
      try {
        const csrftoken = document.getElementById('csrf-token').value;
        await fetch('/api/player/sync', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrftoken
          },
          body: JSON.stringify({ steam_id: CURRENT_USER_STEAM_ID })
        });

        const resp = await fetch(`/api/player-position?steam_id=${CURRENT_USER_STEAM_ID}`);
        const data = await resp.json();
        userRatingSpan.textContent = data.rating;

        await loadLeaderboard();
      } catch (e) {
        console.error('Ошибка обновления рейтинга', e);
      }

      await loadStats();
      showNotification('Рейтинг и статистика обновлены');
    });
  }

  async function loadLeaderboard() {
    const resp = await fetch('/api/leaderboard');
    const players = await resp.json();
    leaderboardBody.innerHTML = '';
    let currentUserInTop = false;

    players.forEach((p, i) => {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${i + 1}</td><td>${p.personaname}</td><td>${p.rating}</td>`;
      leaderboardBody.appendChild(tr);
      if (p.steamid === CURRENT_USER_STEAM_ID) {
        currentUserInTop = true;
      }
    });

    if (!currentUserInTop) {
      try {
        const resp = await fetch(`/api/player-position?steam_id=${CURRENT_USER_STEAM_ID}`);
        const data = await resp.json();

        const separator = document.createElement('tr');
        separator.innerHTML = `<td colspan="3" style="text-align:center; color:#777;">...</td>`;
        leaderboardBody.appendChild(separator);

        const userRow = document.createElement('tr');
        userRow.innerHTML = `<td>${data.position}</td><td>${data.nickname}</td><td>${data.rating}</td>`;
        userRow.classList.add('user-position');
        leaderboardBody.appendChild(userRow);
      } catch (e) {
        console.error("Ошибка получения позиции игрока", e);
      }
    }
  }

  // Инициализация
  loadLeaderboard();
  {% if request.user.is_authenticated %}
    loadStats();
  {% endif %}
</script>

</body>
</html>
